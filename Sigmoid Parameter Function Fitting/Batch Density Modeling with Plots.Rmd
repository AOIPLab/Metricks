---
title: "Foveal Cone Density Modeling with Plotting"
output:
  pdf_document: default
  html_document: default
  word_document: default
date: "2025-11-10"
---

<!--
================================================================================
                          Input File Documentation
================================================================================

This script requires 1-2 input folders depending on comparison mode, plus a parameter file.

1. Data input folder(s) containing individual subject files (CSV or XLSX supported)
   - Each file = one subject
   - Format: no headers
   - Column 1: E (Eccentricity)
   - Column 2: D (Density)
   - The filename (without extension) will be used as the Subject ID
   
   Example file (JC_0007.csv):
   0,150000
   10,145000
   20,138000
   ...

   If comparison mode = yes: Two folders required (Group 1 and Group 2)
   If comparison mode = no:  One folder required

2. Parameter ranges file: parameter_ranges.csv or parameter_ranges.xlsx (must be in same folder as input data)
   - Format: no headers
   - Row 1: a_min, a_max, a_start (this is the seed value, Wolf used average for their data as the seed)
   - Row 2: b_min, b_max, b_start
   - Row 3: c_min, c_max, c_start
   
   Example:
   0.01,50000,50
   1,200,2
   0,500,0.5

================================================================================
-->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# ---- INTERACTIVE PROMPTS ----
# Prompt for version number
version_number <- as.integer(readline(prompt = "Enter version number (integer): "))

# Use current date automatically
run_date <- format(Sys.Date(), "%m%d%y")

# Prompt for first input folder
cat("\nNote: Provide a folder path containing individual subject files.\n")
cat("  Each file should have NO headers, with Column 1 = E, Column 2 = D\n")
cat("  Supported formats: .csv or .xlsx\n")
cat("  Subject ID will be extracted from filename.\n")
input_folder_1 <- readline(prompt = "Enter path to folder containing subject files: ")

# Prompt for comparison mode
comparison_mode <- tolower(readline(prompt = "Do you want to compare two groups? (yes/no): "))
comparison_mode <- comparison_mode %in% c("yes", "y")

# Prompt for second input folder if comparison mode is enabled
if (comparison_mode) {
  input_folder_2 <- readline(prompt = "Enter path to second folder (e.g., control subjects): ")
  group_1_name <- readline(prompt = "Enter name for Group 1 (first folder): ")
  group_2_name <- readline(prompt = "Enter name for Group 2 (second folder): ")
} else {
  group_1_name <- ""  # No group name prefix for single group analysis
}

# Helper function to read CSV or XLSX files (raw, no headers)
read_data_file <- function(filepath, col_names = FALSE) {
  ext <- tolower(tools::file_ext(filepath))
  if (ext == "xlsx") {
    return(as.data.frame(read_excel(filepath, col_names = col_names)))
  } else if (ext == "csv") {
    return(read.csv(filepath, header = col_names, stringsAsFactors = FALSE))
  } else {
    stop("Unsupported file format. Please use .csv or .xlsx")
  }
}

# Load parameter ranges (assumed to be in same folder as input data)
# Check for xlsx first, then csv
param_xlsx <- file.path(input_folder_1, "parameter_ranges.xlsx")
param_csv <- file.path(input_folder_1, "parameter_ranges.csv")

if (file.exists(param_xlsx)) {
  param_ranges <- read_data_file(param_xlsx, col_names = FALSE)
} else if (file.exists(param_csv)) {
  param_ranges <- read_data_file(param_csv, col_names = FALSE)
} else {
  stop(paste("Parameter ranges file not found in", input_folder_1, "- Please provide parameter_ranges.csv or parameter_ranges.xlsx"))
}

# Convert all values to numeric
a_min <- as.numeric(param_ranges[1, 1])
a_max <- as.numeric(param_ranges[1, 2])
a_start <- as.numeric(param_ranges[1, 3])
b_min <- as.numeric(param_ranges[2, 1])
b_max <- as.numeric(param_ranges[2, 2])
b_start <- as.numeric(param_ranges[2, 3])
c_min <- as.numeric(param_ranges[3, 1])
c_max <- as.numeric(param_ranges[3, 2])
c_start <- as.numeric(param_ranges[3, 3])

cat("\nParameter ranges and starting values loaded:\n")
cat("  a:", a_min, "-", a_max, "(start:", a_start, ")\n")
cat("  b:", b_min, "-", b_max, "(start:", b_start, ")\n")
cat("  c:", c_min, "-", c_max, "(start:", c_start, ")\n")

# Create version suffix for output files
version_suffix <- paste0("_v", version_number, "_", run_date)
```

This first part loads density data and fits a nonlinear least squares regression model on them to define optimal parameters.

```{r define model}
library(minpack.lm)
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)
library(zoo)
library(openxlsx)
library(readxl)

# Function to load all subject files from a folder (supports CSV and XLSX)
load_subjects_from_folder <- function(folder_path) {
  # List all CSV and XLSX files in the folder
  csv_files <- list.files(folder_path, pattern = "\\.csv$", full.names = TRUE, ignore.case = TRUE)
  xlsx_files <- list.files(folder_path, pattern = "\\.xlsx$", full.names = TRUE, ignore.case = TRUE)
  all_files <- c(csv_files, xlsx_files)
  
  if (length(all_files) == 0) {
    stop(paste("No CSV or XLSX files found in folder:", folder_path))
  }
  
  cat("  Found", length(all_files), "files in folder\n")
  
  # Read each file and combine
  all_data <- list()
  
  for (filepath in all_files) {
    # Extract subject ID from filename (remove extension)
    filename <- basename(filepath)
    subject_id <- sub("\\.(csv|xlsx)$", "", filename, ignore.case = TRUE)
    
    # Read the file (no headers, 2 columns: E, D)
    file_data <- read_data_file(filepath, col_names = FALSE)
    file_data <- as.data.frame(file_data)
    
    # Ensure we have at least 2 columns
    if (ncol(file_data) < 2) {
      warning(paste("Skipping file with insufficient columns:", filename))
      next
    }
    
    # Create subject data frame
    subject_df <- data.frame(
      Subject = subject_id,
      E = as.numeric(file_data[, 1]),
      D = as.numeric(file_data[, 2]),
      stringsAsFactors = FALSE
    )
    
    all_data[[length(all_data) + 1]] <- subject_df
  }
  
  # Combine all subjects
  combined <- bind_rows(all_data)
  
  # Remove NA rows
  combined <- combined[complete.cases(combined), ]
  
  return(combined)
}

# Load subjects from first folder
cat("Loading subjects from folder 1...\n")
data_group_1 <- load_subjects_from_folder(input_folder_1)

# Print summary of loaded data
if (group_1_name == "") {
  cat("Subjects loaded:", length(unique(data_group_1$Subject)), "\n")
} else {
  cat(group_1_name, "subjects:", length(unique(data_group_1$Subject)), "\n")
}

# Load subjects from second folder if comparison mode is enabled
if (comparison_mode) {
  cat("Loading subjects from folder 2...\n")
  data_group_2 <- load_subjects_from_folder(input_folder_2)
  cat(group_2_name, "subjects:", length(unique(data_group_2$Subject)), "\n")
}
```


Final Attempt at Parameter Outputs

```{r sigmoid - nlsM for RSs}

# ---- Function to fit sigmoid using nonlinear least squares ----
library(minpack.lm)

fit_sigmoid_nls_rss <- function(df, a_lower, a_upper, a_init, b_lower, b_upper, b_init, c_lower, c_upper, c_init) {
  
  # Fixed D0: first point (E=0) or max(D) if missing
  D0_val <- ifelse(any(df$E == 0), df$D[df$E == 0][1], max(df$D))
  
  # Sigmoid model
  sigmoid_formula <- D ~ D0_val / ((1 + (E / a)^b)^c)
  
  # Starting values (user-defined)
  start_vals <- list(a = a_init, b = b_init, c = c_init)
  
  # Fit model using nonlinear least squares with user-defined bounds
  fit <- tryCatch(
    nlsLM(
      formula = sigmoid_formula,
      data = df,
      start = start_vals,
      lower = c(a = a_lower, b = b_lower, c = c_lower),
      upper = c(a = a_upper, b = b_upper, c = c_upper),
      control = nls.lm.control(maxiter = 1000)
    ),
    error = function(e) NULL
  )
  
  # If fit fails
  if (is.null(fit)) {
    return(list(
      params = c(a = NA, b = NA, c = NA),
      RSS    = NA,
      RMSE=NA,
      D0     = D0_val,
      model_fun = function(E, a, b, c) rep(NA, length(E))
    ))
  }
  
  # Extract parameters
  p <- coef(fit)
  
  # Compute RSS+RMSE directly from residuals stored in fit
  rss_val <- sum(residuals(fit)^2)
  rmse_val <- sqrt(sum(residuals(fit)^2) / nrow(df))
  
  # Model function for plotting
  model_fun <- function(E, a, b, c) {
    D0_val / ((1 + (E / a)^b)^c)
  }
  
  list(
    params = p,
    RSS    = rss_val,
    RMSE    = rmse_val,
    D0     = D0_val,
    model_fun = model_fun
  )
}

# ---- Helper function to compute CI limits for the mean ----
mean_ci <- function(values, level = 0.95) {
  n <- sum(!is.na(values))
  m <- mean(values, na.rm = TRUE)
  s <- sd(values, na.rm = TRUE)
  
  if (n < 2 || is.na(s)) {
    return(c(lower = NA, upper = NA))
  }
  
  error <- qt((1 + level)/2, df = n - 1) * s / sqrt(n)
  
  c(lower = m - error, upper = m + error)
}

# ---- Function to summarize one dataset (nicely formatted) ----
summarize_dataset <- function(df) {
  
  numeric_vars <- c("a", "b", "c", "D0", "RMSE", "RSS")
  
  stats <- lapply(numeric_vars, function(var) {
    vals <- df[[var]]
    m <- mean(vals, na.rm = TRUE)
    sd_val <- sd(vals, na.rm = TRUE)
    min_val <- min(vals, na.rm = TRUE)
    max_val <- max(vals, na.rm = TRUE)
    n_val <- length(unique(df$Subject))
    ci <- mean_ci(vals, level = 0.95)
    
    c(
      Mean = m,
      SD = sd_val,
      Min = min_val,
      Max = max_val,
      N = n_val,
      CI_lower = ci[1],
      CI_upper = ci[2]
    )
  })
  
  stats_df <- as.data.frame(do.call(cbind, stats))
  colnames(stats_df) <- numeric_vars
  stats_df$Statistic <- rownames(stats_df)
  stats_df <- stats_df[, c("Statistic", numeric_vars)]
  
  rownames(stats_df) <- NULL
  return(stats_df)
}
```

```{r group1 analysis}
# ---- Prepare long data ----

long_df <- data_group_1 %>%
  select(Subject, E, D)

# ---- Create plots folder ----
if (group_1_name == "") {
  plots_dir_1 <- "Fit Plots"
} else {
  plots_dir_1 <- paste0(group_1_name, "Fit Plots")
}
if (!dir.exists(plots_dir_1)) dir.create(plots_dir_1)

# ---- Fit all subjects and save plots + individual CSVs ----
master_df_nls <- lapply(split(long_df, long_df$Subject), function(x) {
  
  fit_obj <- fit_sigmoid_nls_rss(x, a_min, a_max, a_start, b_min, b_max, b_start, c_min, c_max, c_start)
  params <- fit_obj$params
  # Ensure names exist
  if(is.null(names(params))) names(params) <- c("a","b","c")
  D0     <- fit_obj$D0
  RSS    <- fit_obj$RSS
  RMSE    <- fit_obj$RMSE
  model_fun <- fit_obj$model_fun
  
  df <- as.data.frame(t(params))
  df$D0 <- D0
  df$Subject <- unique(x$Subject)
  df$RSS <- RSS
  df$RMSE<-RMSE
  
  # Reorder columns for output
  df <- df[, c("Subject", "a", "b", "c", "D0", "RMSE", "RSS")]
  
  # Write individual subject CSV
  safe_subject <- gsub("[^A-Za-z0-9_]", "_", unique(x$Subject))
  write.csv(df, file.path(plots_dir_1, paste0(safe_subject, "_parameters.csv")), row.names = FALSE)
  
  # Only plot if fit succeeded
  if(!all(is.na(params))) {
    model_pred <- model_fun(x$E, params["a"], params["b"], params["c"])
    
    gg <- ggplot(x, aes(E, D)) +
      geom_point(color = "black", alpha = 0.7, size = 2) +
      geom_line(aes(y = model_pred), color = "#0072B2", linewidth = 1.2) +
      theme_minimal(base_size = 14) +
      labs(
        title = paste0("Subject: ", unique(x$Subject)),
        x = "Eccentricity",
        y = "Density",
        subtitle = paste0(
          "a=", round(params["a"],3), " | ",
          "b=", round(params["b"],3), " | ",
          "c=", round(params["c"],3), " | ",
          "D0=", round(D0,3), " | ",
          "RSS=", round(RSS,4),
          "RMSE=", round(RMSE,4)
        )
      )
    
    ggsave(file.path(plots_dir_1, paste0("fit_plot_", safe_subject, ".png")), gg,
           width = 6, height = 4, dpi = 300)
  }
  
  df
}) %>% bind_rows() %>%
  select(Subject, a, b, c, D0, RMSE, RSS)

group_1_parameters <- master_df_nls

# ---- Build filename prefix (handle empty group name) ----
file_prefix_1 <- if (group_1_name == "") "density" else group_1_name

# ---- Create nicely formatted summary statistics ----
summary_stats <- summarize_dataset(master_df_nls)

# Round values for display (except Statistic column)
for (col in names(summary_stats)) {
  if (col != "Statistic") {
    summary_stats[[col]] <- round(summary_stats[[col]], 3)
  }
}

# ---- Create combined Excel workbook ----
wb_1 <- createWorkbook()

# Sheet 1: Individual Results
addWorksheet(wb_1, "Individual Results")
writeData(wb_1, "Individual Results", master_df_nls)

# Sheet 2: Summary Statistics
addWorksheet(wb_1, "Summary Statistics")
writeData(wb_1, "Summary Statistics", summary_stats)

# Save workbook
saveWorkbook(wb_1, file.path(plots_dir_1, paste0(file_prefix_1, "_results", version_suffix, ".xlsx")), overwrite = TRUE)

# Plot density parameters
parameters_group_1 <- group_1_parameters %>%
  pivot_longer(
    cols = -Subject,
    names_to = "Parameter",
    values_to = "Value"
  )

plot_title_1 <- if (group_1_name == "") {
  "Density Plots for Parameters"
} else {
  paste0("Density Plots for ", group_1_name, " Parameters")
}

p_group_1 <- ggplot(parameters_group_1, aes(x = Value)) +
  geom_density(fill = "skyblue", alpha = 0.5) +
  facet_wrap(~ Parameter, scales = "free") +
  theme_bw() +
  labs(title = plot_title_1, x = "Value", y = "Density")

ggsave(
  filename = file.path(plots_dir_1, paste0(file_prefix_1, "_parameter_densities.png")),
  plot = p_group_1,
  width = 10,
  height = 8,
  dpi = 300
)
```


```{r group2 analysis, eval=comparison_mode}
# ---- This chunk only runs if comparison_mode is TRUE ----

# ---- Prepare long data ----
long_df <- data_group_2 %>%
  select(Subject, E, D)

# ---- Create plots folder ----
plots_dir_2 <- paste0(group_2_name, " Plots")
if (!dir.exists(plots_dir_2)) dir.create(plots_dir_2)

# ---- Fit all subjects and save plots + individual CSVs ----
master_df_nls <- lapply(split(long_df, long_df$Subject), function(x) {
  
  fit_obj <- fit_sigmoid_nls_rss(x, a_min, a_max, a_start, b_min, b_max, b_start, c_min, c_max, c_start)
  params <- fit_obj$params
  # Ensure names exist
  if(is.null(names(params))) names(params) <- c("a","b","c")
  D0     <- fit_obj$D0
  RSS    <- fit_obj$RSS
  RMSE    <- fit_obj$RMSE
  model_fun <- fit_obj$model_fun
  
  df <- as.data.frame(t(params))
  df$D0 <- D0
  df$Subject <- unique(x$Subject)
  df$RSS <- RSS
  df$RMSE<-RMSE
  
  # Reorder columns for output
  df <- df[, c("Subject", "a", "b", "c", "D0", "RMSE", "RSS")]
  
  # Write individual subject CSV
  safe_subject <- gsub("[^A-Za-z0-9_]", "_", unique(x$Subject))
  write.csv(df, file.path(plots_dir_2, paste0(safe_subject, "_parameters.csv")), row.names = FALSE)
  
  # Only plot if fit succeeded
  if(!all(is.na(params))) {
    model_pred <- model_fun(x$E, params["a"], params["b"], params["c"])
    
    gg <- ggplot(x, aes(E, D)) +
      geom_point(color = "black", alpha = 0.7, size = 2) +
      geom_line(aes(y = model_pred), color = "#0072B2", linewidth = 1.2) +
      theme_minimal(base_size = 14) +
      labs(
        title = paste0("Subject: ", unique(x$Subject)),
        x = "Eccentricity",
        y = "Density",
        subtitle = paste0(
          "a=", round(params["a"],3), " | ",
          "b=", round(params["b"],3), " | ",
          "c=", round(params["c"],3), " | ",
          "D0=", round(D0,3), " | ",
          "RSS=", round(RSS,4),
          "RMSE=", round(RMSE,4)
        )
      )
    
    ggsave(file.path(plots_dir_2, paste0("fit_plot_", safe_subject, ".png")), gg,
           width = 6, height = 4, dpi = 300)
  }
  
  df
}) %>% bind_rows() %>%
  select(Subject, a, b, c, D0, RMSE, RSS)

group_2_parameters <- master_df_nls

# ---- Create nicely formatted summary statistics ----
summary_stats_2 <- summarize_dataset(master_df_nls)

# Round values for display (except Statistic column)
for (col in names(summary_stats_2)) {
  if (col != "Statistic") {
    summary_stats_2[[col]] <- round(summary_stats_2[[col]], 3)
  }
}

# ---- Create combined Excel workbook ----
wb_2 <- createWorkbook()

# Sheet 1: Individual Results
addWorksheet(wb_2, "Individual Results")
writeData(wb_2, "Individual Results", master_df_nls)

# Sheet 2: Summary Statistics
addWorksheet(wb_2, "Summary Statistics")
writeData(wb_2, "Summary Statistics", summary_stats_2)

# Save workbook
saveWorkbook(wb_2, file.path(plots_dir_2, paste0(group_2_name, "_results", version_suffix, ".xlsx")), overwrite = TRUE)

# Plot density parameters
parameters_group_2 <- group_2_parameters %>%
  pivot_longer(
    cols = -Subject,
    names_to = "Parameter",
    values_to = "Value"
  )

p_group_2 <- ggplot(parameters_group_2, aes(x = Value)) +
  geom_density(fill = "#ff7f0e", alpha = 0.5) +
  facet_wrap(~ Parameter, scales = "free") +
  theme_bw() +
  labs(title = paste0("Density Plots for ", group_2_name, " Parameters"), x = "Value", y = "Density")

ggsave(
  filename = file.path(plots_dir_2, paste0(group_2_name, "_parameter_densities.png")),
  plot = p_group_2,
  width = 10,
  height = 8,
  dpi = 300
)
```

Now export plots and potentially run comparisons

```{r Export Summary, eval=comparison_mode}
# ---- This chunk only runs if comparison_mode is TRUE ----

plots_dir <- "Parameter Summaries"
if (!dir.exists(plots_dir)) dir.create(plots_dir)

# ---- Helper function: Calculate rank-biserial correlation effect size ----
calc_effect_size <- function(x, y) {
  # Rank-biserial correlation from Wilcoxon test
  # r = 1 - (2U)/(n1*n2) where U is the smaller of U1 and U2
  n1 <- length(na.omit(x))
  n2 <- length(na.omit(y))
  
  if (n1 == 0 || n2 == 0) return(NA)
  
  test <- wilcox.test(x, y, exact = FALSE)
  U <- test$statistic
  
  # Effect size r = 1 - (2U)/(n1*n2)
  r <- 1 - (2 * U) / (n1 * n2)
  return(abs(r))  # Return absolute value
}

# ---- Helper function: Determine significance stars ----
get_significance <- function(p) {
  if (is.na(p)) return("NA")
  if (p < 0.001) return("***")
  if (p < 0.01) return("**")
  if (p < 0.05) return("*")
  return("ns")
}

# ---- Create summaries for both groups ----
summary_g1 <- summarize_dataset(group_1_parameters)
summary_g2 <- summarize_dataset(group_2_parameters)

# Round values
for (col in names(summary_g1)) {
  if (col != "Statistic") {
    summary_g1[[col]] <- round(summary_g1[[col]], 3)
    summary_g2[[col]] <- round(summary_g2[[col]], 3)
  }
}

# ---- Create side-by-side summary ----
params <- c("a", "b", "c", "D0", "RMSE", "RSS")
side_by_side <- data.frame(Statistic = summary_g1$Statistic)

for (param in params) {
  col_g1 <- paste0(param, " (", group_1_name, ")")
  col_g2 <- paste0(param, " (", group_2_name, ")")
  side_by_side[[col_g1]] <- summary_g1[[param]]
  side_by_side[[col_g2]] <- summary_g2[[param]]
}

# ---- Create comprehensive comparison table ----
comparison_params <- c("a", "b", "c", "D0", "RMSE")

comparison_table <- data.frame(
  Parameter = comparison_params,
  stringsAsFactors = FALSE
)

# Add group means
comparison_table[[paste0(group_1_name, "_Mean")]] <- sapply(comparison_params, function(p) {
  round(mean(group_1_parameters[[p]], na.rm = TRUE), 3)
})

comparison_table[[paste0(group_2_name, "_Mean")]] <- sapply(comparison_params, function(p) {
  round(mean(group_2_parameters[[p]], na.rm = TRUE), 3)
})

# Add Wilcoxon test results
comparison_table$W_statistic <- sapply(comparison_params, function(p) {
  round(wilcox.test(group_1_parameters[[p]], group_2_parameters[[p]], exact = FALSE)$statistic, 2)
})

comparison_table$p_value <- sapply(comparison_params, function(p) {
  pval <- wilcox.test(group_1_parameters[[p]], group_2_parameters[[p]], exact = FALSE)$p.value
  round(pval, 4)
})

# Add effect sizes
comparison_table$Effect_Size_r <- sapply(comparison_params, function(p) {
  r <- calc_effect_size(group_1_parameters[[p]], group_2_parameters[[p]])
  paste0("r = ", round(r, 3))
})

# Add significance stars
comparison_table$Significance <- sapply(comparison_table$p_value, get_significance)

# ---- Create Excel workbook ----
wb <- createWorkbook()

# Sheet 1: Side-by-Side Summary
addWorksheet(wb, "Side-by-Side Summary")
writeData(wb, "Side-by-Side Summary", side_by_side)

# Sheet 2: Statistical Comparisons
addWorksheet(wb, "Statistical Comparisons")
writeData(wb, "Statistical Comparisons", comparison_table)

# Sheet 3: Group 1 Summary
addWorksheet(wb, paste0(group_1_name, " Summary"))
writeData(wb, paste0(group_1_name, " Summary"), summary_g1)

# Sheet 4: Group 2 Summary
addWorksheet(wb, paste0(group_2_name, " Summary"))
writeData(wb, paste0(group_2_name, " Summary"), summary_g2)

# Save workbook
saveWorkbook(wb, file.path(plots_dir, paste0("Group_Comparison", version_suffix, ".xlsx")), overwrite = TRUE)

cat("\nComparison workbook saved with sheets:\n")
cat("  1. Side-by-Side Summary\n")
cat("  2. Statistical Comparisons (Wilcoxon + Effect Sizes)\n")
cat("  3.", group_1_name, "Summary\n")
cat("  4.", group_2_name, "Summary\n")
```

Comparisons and violin plots, if necessary

```{r parameter density and violin plots, eval=comparison_mode}
# ---- This chunk only runs if comparison_mode is TRUE ----

ggsave(
  filename = file.path(plots_dir, paste0(group_2_name, "_parameter_densities.png")),
  plot = p_group_2,
  width = 10,
  height = 8,
  dpi = 300)
ggsave(
  filename = file.path(plots_dir, paste0(group_1_name, "_parameter_densities.png")),
  plot = p_group_1,
  width = 10,
  height = 8,
  dpi = 300)

library(ggplot2)
library(dplyr)
library(tidyr)

# Combine datasets into one long-format dataframe
datasets_long <- bind_rows(
  group_2_parameters %>% mutate(Dataset = group_2_name),
  group_1_parameters %>% mutate(Dataset = group_1_name)
)

# Variables to plot
vars_to_plot <- c("a", "b", "c", "RMSE")

# Convert to long format
df_long <- datasets_long %>%
  select(all_of(vars_to_plot), Dataset) %>%
  pivot_longer(
    cols = all_of(vars_to_plot),
    names_to = "Variable",
    values_to = "Value"
  )

# Define colors for the two groups
group_colors <- setNames(c("#2ca02c", "#ff7f0e"), c(group_1_name, group_2_name))

# Violin plot
combined_violin <- ggplot(df_long, aes(x = Dataset, y = Value, fill = Dataset)) +
  geom_violin(trim = FALSE, alpha = 0.6) +
  geom_boxplot(width = 0.1, fill = "white", outlier.shape = NA) +
  facet_wrap(~ Variable, scales = "free_y") +
  theme_minimal() +
  labs(
    title = "Violin Plots of Density Parameters by Dataset",
    x = "Dataset",
    y = "Value"
  ) +
  scale_fill_manual(values = group_colors) +
  theme(legend.position = "none")

ggsave(
  filename = file.path(plots_dir, "violin_all_parameters.png"),
  plot = combined_violin,
  dpi = 300)


# Individual Violin Plots

for (var in vars_to_plot) {
  
  df_var <- df_long %>% filter(Variable == var)
  
  # Base violin plot (common to both)
  p_base <- ggplot(df_var, aes(x = Dataset, y = Value, fill = Dataset)) +
    geom_violin(trim = FALSE, alpha = 0.6) +
    geom_boxplot(width = 0.05, fill = "white", outlier.shape = NA) +
    theme_minimal(base_size = 14) +
    labs(
      title = paste("Violin Plot of", var, "by Dataset"),
      x = "Dataset",
      y = var
    ) +
    scale_fill_manual(values = group_colors) +
    theme(legend.position = "none")
  
  # --- Original (auto-scaled) ---
  ggsave(
    filename = file.path(plots_dir, paste0("violin_", var, ".png")),
    plot = p_base,
    width = 6, height = 5,
    dpi = 300
  )
  
  # --- Scaled version (only max constrained for a and c) ---
  p_scaled <- p_base
  if (var == "a") {
    p_scaled <- p_scaled + coord_cartesian(ylim = c(NA, 300))
  } else if (var == "c") {
    p_scaled <- p_scaled + coord_cartesian(ylim = c(NA, 2))
  }
  
  ggsave(
    filename = file.path(plots_dir, paste0("scaled_violin_", var, ".png")),
    plot = p_scaled,
    width = 6, height = 5,
    dpi = 300
  )
}
```
